dogma_v1 utf-8
- identifier  = bonjson
- description = Binary Object Notation for JSON
- reference   = https://bonjson.org
- dogma       = https://github.com/kstenerud/dogma/blob/master/v1/dogma_v1.0.md

document          = byte_order(lsb, ordered_document);
ordered_document  = value;

value             = array | object | number | boolean | string | null;

# Types

# Containers use delimiter-terminated encoding.
# 0xFC/0xFD opens, 0xFE closes.
array             = u8(0xfc) & value* & u8(0xfe);
object            = u8(0xfd) & (string & value)* & u8(0xfe);

number            = int_small | int_unsigned | int_signed | float_32 | float_64 | big_number;
int_small         = u8(var(code, 0x00~0xc8));  # value = code - 100
int_unsigned      = u8(0xe0) & ordered(uint( 8, ~))
                  | u8(0xe1) & ordered(uint(16, ~))
                  | u8(0xe2) & ordered(uint(32, ~))
                  | u8(0xe3) & ordered(uint(64, ~))
                  ;
int_signed        = u8(0xe4) & ordered(sint( 8, ~))
                  | u8(0xe5) & ordered(sint(16, ~))
                  | u8(0xe6) & ordered(sint(32, ~))
                  | u8(0xe7) & ordered(sint(64, ~))
                  ;
float_32          = u8(0xcb) & ordered(f32(~));
float_64          = u8(0xcc) & ordered(f64(~));
big_number        = u8(0xca) & zigzag_leb128(~) & zigzag_leb128(~);

boolean           = true | false;
false             = u8(0xce);
true              = u8(0xcf);

null              = u8(0xcd);

string            = string_short | string_long;
string_short      = u8(var(code, 0xd0~0xdf)) & sized((code - 0xd0) * 8, char_string*);
string_long       = u8(0xff) & char_string* & u8(0xff);

# Zigzag LEB128: variable-length signed integer encoding.
# Zigzag maps signed to unsigned: 0→0, -1→1, 1→2, -2→3, ...
# LEB128 stores 7 data bits per byte, MSbit=1 means more bytes follow.
zigzag_leb128(v)  = leb128(zigzag(v));
zigzag(v)         = uint(~, (v << 1) ^ (v >> 63));  # signed to unsigned
leb128(v)         = [
                        v <= 0x7f:         uint(7, v) & u1(0);
                        v >  0x7f:         uint(7, v) & u1(1) & leb128(v >> 7);
                    ];

# Primitives & Functions

u1(v)             = uint(1, v);
u8(v)             = uint(8, v);
f32(v)            = float(32, v);
f64(v)            = float(64, v);

char_string       = unicode(Cc,Cf,Co,Cn,L,M,N,P,S,Z); # Category C minus Cs (surrogates)

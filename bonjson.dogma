dogma_v1 utf-8
- identifier  = bonjson
- description = Binary Object Notation for JSON
- reference   = https://bonjson.org
- dogma       = https://github.com/kstenerud/dogma/blob/master/v1/dogma_v1.0.md

document          = byte_order(lsb, ordered_document);
ordered_document  = value;

value             = typed_array | array | object | number | boolean | string | null;

# Types

# Containers use delimiter-terminated encoding.
# 0xFC/0xFD opens, 0xFE closes.
# Typed array is a compact encoding for homogeneous numeric arrays.
typed_array       = u8(0xfb) & typed_element_type & leb128(var(count, ~))
                  & sized(count * typed_element_size * 8,
                      ordered(uint(count * typed_element_size * 8, ~)));
typed_element_type = u8(var(etype, 0xcb | 0xcc | 0xe0~0xe7));
typed_element_size = [
                        etype == 0xe0: 1;  # uint8
                        etype == 0xe4: 1;  # sint8
                        etype == 0xe1: 2;  # uint16
                        etype == 0xe5: 2;  # sint16
                        etype == 0xe2: 4;  # uint32
                        etype == 0xe6: 4;  # sint32
                        etype == 0xcb: 4;  # float32
                        etype == 0xe3: 8;  # uint64
                        etype == 0xe7: 8;  # sint64
                        etype == 0xcc: 8;  # float64
                    ];
array             = u8(0xfc) & value* & u8(0xfe);
object            = u8(0xfd) & (string & value)* & u8(0xfe);

number            = int_small | int_unsigned | int_signed | float_32 | float_64 | big_number;
int_small         = u8(var(code, 0x00~0xc8));  # value = code - 100
int_unsigned      = u8(0xe0) & ordered(uint( 8, ~))
                  | u8(0xe1) & ordered(uint(16, ~))
                  | u8(0xe2) & ordered(uint(32, ~))
                  | u8(0xe3) & ordered(uint(64, ~))
                  ;
int_signed        = u8(0xe4) & ordered(sint( 8, ~))
                  | u8(0xe5) & ordered(sint(16, ~))
                  | u8(0xe6) & ordered(sint(32, ~))
                  | u8(0xe7) & ordered(sint(64, ~))
                  ;
float_32          = u8(0xcb) & ordered(f32(~));
float_64          = u8(0xcc) & ordered(f64(~));
# Big number: exponent (zigzag LEB128), signed_length (zigzag LEB128),
# then abs(signed_length) unsigned LE magnitude bytes.
# The sign of signed_length indicates the sign of the significand.
big_number        = u8(0xca) & zigzag_leb128(~) & zigzag_leb128(var(slen, ~))
                  & sized(abs(slen) * 8, uint(abs(slen) * 8, ~));

boolean           = true | false;
false             = u8(0xce);
true              = u8(0xcf);

null              = u8(0xcd);

string            = string_short | string_long;
string_short      = u8(var(code, 0xd0~0xdf)) & sized((code - 0xd0) * 8, char_string*);
string_long       = u8(0xff) & char_string* & u8(0xff);

# Zigzag LEB128: variable-length signed integer encoding.
# Zigzag maps signed to unsigned: 0→0, -1→1, 1→2, -2→3, ...
# LEB128 stores 7 data bits per byte, MSbit=1 means more bytes follow.
zigzag_leb128(v)  = leb128(zigzag(v));
zigzag(v)         = uint(~, (v << 1) ^ (v >> (bit_width(v) - 1)));  # signed to unsigned
leb128(v)         = [
                        v <= 0x7f: uint(7, v) & u1(0);
                        v >  0x7f: uint(7, v) & u1(1) & leb128(v >> 7);
                    ];

# Primitives & Functions

u1(v)             = uint(1, v);
u8(v)             = uint(8, v);
f32(v)            = float(32, v);
f64(v)            = float(64, v);

char_string       = unicode(Cc,Cf,Co,Cn,L,M,N,P,S,Z); # Category C minus Cs (surrogates)

dogma_v1 utf-8
- identifier  = bonjson
- description = Binary Object Notation for JSON
- reference   = https://bonjson.org
- dogma       = https://github.com/kstenerud/dogma/blob/master/v1/dogma_v1.0.md

document          = byte_order(lsb, ordered_document);
ordered_document  = value;

value             = array | object | number | boolean | string | null;

# Types

array             = u8(0x91) & value* & end_container;
object            = u8(0x92) & (string & value)* & end_container;
end_container     = u8(0x93);

number            = int_small | uint | sint | float_16 | float_32 | float_64 | big_number;
int_small         = u8(0x00~0x6a) | u8(0x97~0xff);
uint              = u4(7) & u1(0) & u3(var(count, ~)) & ordered(uint((count+1)*8, ~));
sint              = u4(7) & u1(1) & u3(var(count, ~)) & ordered(sint((count+1)*8, ~));
float_16          = u8(0x6b) & ordered(f16(~));
float_32          = u8(0x6c) & ordered(f32(~));
float_64          = u8(0x6d) & ordered(f64(~));
big_number        = big_number_pos | big_number_neg;
big_number_pos    = u8(0x6e) & big_number_value;
big_number_neg    = u8(0x6f) & big_number_value;
big_number_value  = var(header, big_number_header)
                  & ordered(uint(header.sig_length*8, ~))
                  & ordered(sint(header.exp_length*8, ~))
                  ;
big_number_header = uleb128(uany(var(sig_length, ~)) & u2(var(exp_length, ~)));

boolean           = true | false;
false             = u8(0x94);
true              = u8(0x95);

string            = string_short | string_long;
string_short      = u4(8) & u4(var(count, ~)) & sized(count*8, char_string*);
string_long       = u8(0x90) & char_string* & u8(0xff);

null              = u8(0x96);

# Primitives & Functions

u1(v)             = uint(1, v);
u2(v)             = uint(2, v);
u3(v)             = uint(3, v);
u4(v)             = uint(4, v);
u8(v)             = uint(8, v);
uany(v)           = uint(~,v);
f16(v)            = bfloat16(v);
f32(v)            = float(32, v);
f64(v)            = float(64, v);

char_string       = '\[0]' ~ '\[10ffff]'; # JSON technically supports unassigned and invalid codepoints

bfloat16(v: bits): bits = """https://en.wikipedia.org/wiki/Bfloat16_floating-point_format""";
uleb128(v: bits): bits = """https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128""";

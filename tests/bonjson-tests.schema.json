{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://bonjson.org/tests/bonjson-tests.schema.json",
  "title": "BONJSON Test Specification",
  "description": "Schema for BONJSON cross-implementation test specifications",
  "type": "object",
  "required": ["type", "version", "tests"],
  "properties": {
    "type": {
      "type": "string",
      "description": "Format identifier for this test specification",
      "const": "bonjson-test"
    },
    "version": {
      "type": "string",
      "description": "Test specification version (full semver: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD])",
      "pattern": "^\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z.-]+)?(\\+[0-9A-Za-z.-]+)?$"
    },
    "tests": {
      "type": "array",
      "description": "Array of test cases (or comment-only section dividers)",
      "items": {
        "$ref": "#/$defs/testEntry"
      }
    }
  },
  "additionalProperties": true,
  "$defs": {
    "testEntry": {
      "description": "Either a test case or a comment-only section divider",
      "oneOf": [
        { "$ref": "#/$defs/commentBlock" },
        { "$ref": "#/$defs/testCase" }
      ]
    },
    "commentBlock": {
      "type": "object",
      "description": "Comment-only entry used as a section divider. All property names must start with '//'.",
      "propertyNames": {
        "pattern": "^//"
      },
      "additionalProperties": {
        "type": "string"
      }
    },
    "testCase": {
      "type": "object",
      "description": "A test case with required name and type fields",
      "required": ["name", "type"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier for the test case (compared case-insensitively for duplicates)",
          "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$"
        },
        "type": {
          "type": "string",
          "description": "Type of test to perform",
          "enum": [
            "encode",
            "decode",
            "roundtrip",
            "encode_error",
            "decode_error"
          ]
        },
        "input": {
          "description": "Input value for encode/roundtrip tests. Can be any JSON value or a special marker object."
        },
        "input_bytes": {
          "type": "string",
          "description": "Input bytes for decode/decode_error tests (hex string, spaces allowed)",
          "pattern": "^[0-9a-fA-F ]*$"
        },
        "expected_bytes": {
          "type": "string",
          "description": "Expected output bytes for encode tests (hex string, spaces allowed)",
          "pattern": "^[0-9a-fA-F ]*$"
        },
        "expected_value": {
          "description": "Expected output value for decode tests. Can be any JSON value or a special marker object."
        },
        "expected_error": {
          "type": "string",
          "description": "Expected error type for error tests",
          "enum": [
            "truncated",
            "trailing_bytes",
            "invalid_type_code",
            "invalid_utf8",
            "nul_character",
            "duplicate_key",
            "unclosed_container",
            "invalid_data",
            "invalid_object_key",
            "value_out_of_range",
            "max_depth_exceeded",
            "max_string_length_exceeded",
            "max_container_size_exceeded",
            "max_document_size_exceeded"
          ]
        },
        "requires": {
          "type": "array",
          "description": "Capabilities required to run this test. Implementations should skip tests requiring capabilities they don't support. Known capabilities: arbitrary_precision_bignumber, bignumber_exponent_gt_127, bignumber_exponent_lt_neg128, nan_infinity_stringify, uint64, int64, negative_zero, raw_string_bytes. Unknown capabilities should cause the test to be skipped (for forward compatibility).",
          "items": {
            "type": "string"
          }
        },
        "options": {
          "type": "object",
          "description": "Optional test configuration",
          "properties": {
            "allow_nul": {
              "type": "boolean",
              "description": "Allow NUL characters in strings"
            },
            "allow_trailing_bytes": {
              "type": "boolean",
              "description": "Allow unconsumed bytes after decoding (default: false)"
            },
            "nan_infinity_behavior": {
              "type": "string",
              "description": "How to handle NaN/Infinity values",
              "enum": ["reject", "allow", "stringify"]
            },
            "duplicate_key": {
              "type": "string",
              "description": "How to handle duplicate object keys",
              "enum": ["reject", "keep_first", "keep_last"]
            },
            "invalid_utf8": {
              "type": "string",
              "description": "How to handle invalid UTF-8 sequences",
              "enum": ["reject", "replace", "delete", "pass_through"]
            },
            "max_depth": {
              "type": "integer",
              "minimum": 0,
              "description": "Maximum container nesting depth (non-negative)"
            },
            "max_container_size": {
              "type": "integer",
              "minimum": 0,
              "description": "Maximum elements in a container (non-negative)"
            },
            "max_string_length": {
              "type": "integer",
              "minimum": 0,
              "description": "Maximum string length in bytes (non-negative)"
            },
            "max_document_size": {
              "type": "integer",
              "minimum": 0,
              "description": "Maximum document size in bytes (non-negative)"
            }
          },
          "additionalProperties": false
        }
      },
      "allOf": [
        {
          "if": {
            "properties": { "type": { "const": "encode" } }
          },
          "then": {
            "required": ["input", "expected_bytes"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "decode" } }
          },
          "then": {
            "required": ["input_bytes", "expected_value"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "roundtrip" } }
          },
          "then": {
            "required": ["input"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "encode_error" } }
          },
          "then": {
            "required": ["input", "expected_error"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "decode_error" } }
          },
          "then": {
            "required": ["input_bytes", "expected_error"]
          }
        }
      ],
      "additionalProperties": true
    },
    "specialValue": {
      "type": "object",
      "description": "Special value marker for numeric values that cannot be safely represented in JSON",
      "properties": {
        "$number": {
          "type": "string",
          "description": "Numeric value as string (case-insensitive): NaN, Infinity, -Infinity, hex float (0x...p...), or decimal"
        }
      },
      "required": ["$number"],
      "additionalProperties": false
    },
    "bytesValue": {
      "type": "object",
      "description": "Raw byte sequence marker for testing invalid UTF-8 handling in expected_value fields",
      "properties": {
        "$bytes": {
          "type": "string",
          "description": "Hexadecimal byte sequence (spaces allowed, even number of hex digits required)",
          "pattern": "^[0-9a-fA-F ]*$"
        }
      },
      "required": ["$bytes"],
      "additionalProperties": false
    }
  }
}

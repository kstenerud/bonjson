{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "Integer encoding tests covering all size variants",
  "tests": [
    {
      "//": "Small integers (-100 to 100) encode as byte = value + 100",
      "name": "smallint_0",
      "type": "encode",
      "input": 0,
      "expected_bytes": "64"
    },
    {
      "name": "smallint_1",
      "type": "encode",
      "input": 1,
      "expected_bytes": "65"
    },
    {
      "name": "smallint_5",
      "type": "encode",
      "input": 5,
      "expected_bytes": "69"
    },
    {
      "name": "smallint_10",
      "type": "encode",
      "input": 10,
      "expected_bytes": "6e"
    },
    {
      "name": "smallint_100",
      "type": "encode",
      "input": 100,
      "expected_bytes": "c8"
    },
    {
      "//": "Small negative integers (-100 to -1) encode as value + 100",
      "name": "smallint_neg1",
      "type": "encode",
      "input": -1,
      "expected_bytes": "63"
    },
    {
      "name": "smallint_neg60",
      "type": "encode",
      "input": -60,
      "expected_bytes": "28"
    },
    {
      "name": "smallint_neg100",
      "type": "encode",
      "input": -100,
      "expected_bytes": "00"
    },
    {
      "//": "Signed int8 (101-127, -101 to -128) uses type code 0xd8",
      "name": "sint8_101",
      "type": "encode",
      "input": 101,
      "expected_bytes": "e4 65"
    },
    {
      "name": "sint8_122",
      "type": "encode",
      "input": 122,
      "expected_bytes": "e4 7a"
    },
    {
      "name": "sint8_126",
      "type": "encode",
      "input": 126,
      "expected_bytes": "e4 7e"
    },
    {
      "name": "sint8_127",
      "type": "encode",
      "input": 127,
      "expected_bytes": "e4 7f"
    },
    {
      "name": "sint8_neg101",
      "type": "encode",
      "input": -101,
      "expected_bytes": "e4 9b"
    },
    {
      "name": "sint8_neg121",
      "type": "encode",
      "input": -121,
      "expected_bytes": "e4 87"
    },
    {
      "name": "sint8_neg127",
      "type": "encode",
      "input": -127,
      "expected_bytes": "e4 81"
    },
    {
      "name": "sint8_neg128",
      "type": "encode",
      "input": -128,
      "expected_bytes": "e4 80"
    },
    {
      "//": "Values 128-255 can be encoded as uint8 (0xd0) or sint16 (0xd9)",
      "//note": "Roundtrip tests verify correctness; decode tests verify specific encodings",
      "name": "roundtrip_128",
      "type": "roundtrip",
      "input": 128
    },
    {
      "name": "roundtrip_180",
      "type": "roundtrip",
      "input": 180
    },
    {
      "name": "roundtrip_200",
      "type": "roundtrip",
      "input": 200
    },
    {
      "name": "roundtrip_255",
      "type": "roundtrip",
      "input": 255
    },
    {
      "//": "Signed int16 uses type code 0xd9 (little-endian)",
      "name": "sint16_1000",
      "type": "encode",
      "input": 1000,
      "expected_bytes": "e5 e8 03"
    },
    {
      "name": "sint16_256",
      "type": "encode",
      "input": 256,
      "expected_bytes": "e5 00 01"
    },
    {
      "name": "sint16_32767",
      "type": "encode",
      "input": 32767,
      "expected_bytes": "e5 ff 7f"
    },
    {
      "name": "sint16_neg1000",
      "type": "encode",
      "input": -1000,
      "expected_bytes": "e5 18 fc"
    },
    {
      "name": "sint16_neg32768",
      "type": "encode",
      "input": -32768,
      "expected_bytes": "e5 00 80"
    },
    {
      "//": "Values 32768-65535 can be encoded as uint16 (0xd1) or sint24 (0xda)",
      "name": "roundtrip_32768",
      "type": "roundtrip",
      "input": 32768
    },
    {
      "name": "roundtrip_65535",
      "type": "roundtrip",
      "input": 65535
    },
    {
      "//": "Signed int24 uses type code 0xda",
      "name": "sint24_65536",
      "type": "encode",
      "input": 65536,
      "expected_bytes": "e6 00 00 01 00"
    },
    {
      "name": "sint24_8388607",
      "type": "encode",
      "input": 8388607,
      "expected_bytes": "e6 ff ff 7f 00"
    },
    {
      "//": "Values 8388608-16777215 can be encoded as uint24 (0xd2) or sint32 (0xdb)",
      "name": "roundtrip_8388608",
      "type": "roundtrip",
      "input": 8388608
    },
    {
      "name": "roundtrip_16777215",
      "type": "roundtrip",
      "input": 16777215
    },
    {
      "//": "Signed int32 uses type code 0xdb",
      "name": "sint32_16777216",
      "type": "encode",
      "input": 16777216,
      "expected_bytes": "e6 00 00 00 01"
    },
    {
      "name": "sint32_2147483647",
      "type": "encode",
      "input": 2147483647,
      "expected_bytes": "e6 ff ff ff 7f"
    },
    {
      "//": "Values 2147483648-4294967295 can be encoded as uint32 (0xd3) or sint40 (0xdc)",
      "name": "roundtrip_2147483648",
      "type": "roundtrip",
      "input": 2147483648
    },
    {
      "name": "roundtrip_4294967295",
      "type": "roundtrip",
      "input": 4294967295
    },
    {
      "//": "Signed int40 uses type code 0xdc",
      "name": "sint40_4294967296",
      "type": "encode",
      "input": 4294967296,
      "expected_bytes": "e7 00 00 00 00 01 00 00 00"
    },
    {
      "name": "sint40_549755813887",
      "type": "encode",
      "input": 549755813887,
      "expected_bytes": "e7 ff ff ff ff 7f 00 00 00"
    },
    {
      "//": "Values 549755813888-1099511627775 can be encoded as uint40 (0xd4) or sint48 (0xdd)",
      "name": "roundtrip_549755813888",
      "type": "roundtrip",
      "input": 549755813888
    },
    {
      "name": "roundtrip_1099511627775",
      "type": "roundtrip",
      "input": 1099511627775
    },
    {
      "//": "Signed int48 uses type code 0xdd",
      "name": "sint48_1099511627776",
      "type": "encode",
      "input": 1099511627776,
      "expected_bytes": "e7 00 00 00 00 00 01 00 00"
    },
    {
      "//": "Example from spec: 0x123456789abc",
      "name": "sint48_20015998343868",
      "type": "encode",
      "input": 20015998343868,
      "expected_bytes": "e7 bc 9a 78 56 34 12 00 00"
    },
    {
      "//": "Value 140737488355328 can be encoded as uint48 (0xd5) or sint56 (0xde)",
      "name": "roundtrip_140737488355328",
      "type": "roundtrip",
      "input": 140737488355328
    },
    {
      "//": "Signed int56 uses type code 0xde",
      "name": "sint56_281474976710656",
      "type": "encode",
      "input": 281474976710656,
      "expected_bytes": "e7 00 00 00 00 00 00 01 00"
    },
    {
      "//": "Value 36028797018963968 can be encoded as uint56 (0xd6) or sint64 (0xdf)",
      "name": "roundtrip_36028797018963968",
      "type": "roundtrip",
      "input": 36028797018963968
    },
    {
      "//": "Signed int64 uses type code 0xdf",
      "name": "sint64_72057594037927936",
      "type": "encode",
      "input": 72057594037927936,
      "expected_bytes": "e7 00 00 00 00 00 00 00 01"
    },
    {
      "name": "sint64_max",
      "type": "encode",
      "input": 9223372036854775807,
      "expected_bytes": "e7 ff ff ff ff ff ff ff 7f"
    },
    {
      "name": "sint64_min",
      "type": "encode",
      "input": -9223372036854775808,
      "expected_bytes": "e7 00 00 00 00 00 00 00 80"
    },
    {
      "//": "Unsigned int64 (values > INT64_MAX) must use type code 0xd7",
      "name": "uint64_9223372036854775808",
      "type": "encode",
      "input": {
        "$number": "9223372036854775808"
      },
      "expected_bytes": "e3 00 00 00 00 00 00 00 80"
    },
    {
      "//": "Example from spec: 0xded0d0d0dedadada",
      "name": "uint64_example",
      "type": "encode",
      "input": {
        "$number": "16055562267086478042"
      },
      "expected_bytes": "e3 da da da de d0 d0 d0 de"
    },
    {
      "name": "uint64_max",
      "type": "encode",
      "input": {
        "$number": "18446744073709551615"
      },
      "expected_bytes": "e3 ff ff ff ff ff ff ff ff"
    },
    {
      "//": "=== Decode tests - verify decoder accepts all valid encodings ===",
      "name": "decode_smallint_50_direct",
      "type": "decode",
      "input_bytes": "96",
      "expected_value": 50
    },
    {
      "//": "Small int encoded as sint8 should decode to same value",
      "name": "decode_50_as_sint8",
      "type": "decode",
      "input_bytes": "e4 32",
      "expected_value": 50
    },
    {
      "//": "Small int encoded as uint8 should decode to same value",
      "name": "decode_50_as_uint8",
      "type": "decode",
      "input_bytes": "e0 32",
      "expected_value": 50
    },
    {
      "//": "Small int encoded as sint16 should decode to same value",
      "name": "decode_50_as_sint16",
      "type": "decode",
      "input_bytes": "e5 32 00",
      "expected_value": 50
    },
    {
      "//": "120 encoded as uint16 should decode correctly",
      "name": "decode_120_as_uint16",
      "type": "decode",
      "input_bytes": "e1 78 00",
      "expected_value": 120
    },
    {
      "//": "Decode tests for unsigned integer encodings",
      "name": "decode_uint8_128",
      "type": "decode",
      "input_bytes": "e0 80",
      "expected_value": 128
    },
    {
      "name": "decode_uint8_180",
      "type": "decode",
      "input_bytes": "e0 b4",
      "expected_value": 180
    },
    {
      "name": "decode_uint8_200",
      "type": "decode",
      "input_bytes": "e0 c8",
      "expected_value": 200
    },
    {
      "name": "decode_uint8_255",
      "type": "decode",
      "input_bytes": "e0 ff",
      "expected_value": 255
    },
    {
      "name": "decode_uint16_32768",
      "type": "decode",
      "input_bytes": "e1 00 80",
      "expected_value": 32768
    },
    {
      "name": "decode_uint16_65535",
      "type": "decode",
      "input_bytes": "e1 ff ff",
      "expected_value": 65535
    },
    {
      "name": "decode_uint24_8388608",
      "type": "decode",
      "input_bytes": "e2 00 00 80 00",
      "expected_value": 8388608
    },
    {
      "name": "decode_uint24_16777215",
      "type": "decode",
      "input_bytes": "e2 ff ff ff 00",
      "expected_value": 16777215
    },
    {
      "name": "decode_uint32_2147483648",
      "type": "decode",
      "input_bytes": "e2 00 00 00 80",
      "expected_value": 2147483648
    },
    {
      "name": "decode_uint32_4294967295",
      "type": "decode",
      "input_bytes": "e2 ff ff ff ff",
      "expected_value": 4294967295
    },
    {
      "name": "decode_uint40_549755813888",
      "type": "decode",
      "input_bytes": "e3 00 00 00 00 80 00 00 00",
      "expected_value": 549755813888
    },
    {
      "name": "decode_uint40_1099511627775",
      "type": "decode",
      "input_bytes": "e3 ff ff ff ff ff 00 00 00",
      "expected_value": 1099511627775
    },
    {
      "name": "decode_uint48_140737488355328",
      "type": "decode",
      "input_bytes": "e3 00 00 00 00 00 80 00 00",
      "expected_value": 140737488355328
    },
    {
      "name": "decode_uint56_36028797018963968",
      "type": "decode",
      "input_bytes": "e3 00 00 00 00 00 00 80 00",
      "expected_value": 36028797018963968
    },
    {
      "//": "Round-trip tests for integer boundaries",
      "name": "roundtrip_int_0",
      "type": "roundtrip",
      "input": 0
    },
    {
      "name": "roundtrip_int_100",
      "type": "roundtrip",
      "input": 100
    },
    {
      "name": "roundtrip_int_neg100",
      "type": "roundtrip",
      "input": -100
    },
    {
      "name": "roundtrip_int_1000",
      "type": "roundtrip",
      "input": 1000
    },
    {
      "name": "roundtrip_int_max_safe",
      "type": "roundtrip",
      "input": 9007199254740991
    },
    {
      "//": "=== Values beyond float64 safe integer range (require int64) ===",
      "//note": "2^53+1 cannot be represented exactly as float64; requires int64 encoding"
    },
    {
      "name": "roundtrip_int64_beyond_float64_precision",
      "type": "roundtrip",
      "input": {
        "$number": "9007199254740993"
      },
      "requires": [
        "int64"
      ]
    },
    {
      "//": "Negative value beyond float64 precision",
      "name": "roundtrip_int64_negative_beyond_float64",
      "type": "roundtrip",
      "input": {
        "$number": "-9007199254740993"
      },
      "requires": [
        "int64"
      ]
    },
    {
      "//": "=== Negative integer boundary encode tests ===",
      "//note": "Testing minimum values for each signed integer size",
      "name": "sint24_neg8388608",
      "type": "encode",
      "input": -8388608,
      "expected_bytes": "e6 00 00 80 ff"
    },
    {
      "name": "sint32_neg2147483648",
      "type": "encode",
      "input": -2147483648,
      "expected_bytes": "e6 00 00 00 80"
    },
    {
      "name": "sint40_neg549755813888",
      "type": "encode",
      "input": -549755813888,
      "expected_bytes": "e7 00 00 00 00 80 ff ff ff"
    },
    {
      "name": "sint48_neg140737488355328",
      "type": "encode",
      "input": -140737488355328,
      "expected_bytes": "e7 00 00 00 00 00 80 ff ff"
    },
    {
      "name": "sint56_neg36028797018963968",
      "type": "encode",
      "input": -36028797018963968,
      "expected_bytes": "e7 00 00 00 00 00 00 80 ff"
    },
    {
      "//": "=== Negative boundary roundtrip tests ===",
      "name": "roundtrip_sint24_min",
      "type": "roundtrip",
      "input": -8388608
    },
    {
      "name": "roundtrip_sint32_min",
      "type": "roundtrip",
      "input": -2147483648
    },
    {
      "name": "roundtrip_sint40_min",
      "type": "roundtrip",
      "input": -549755813888
    },
    {
      "name": "roundtrip_sint48_min",
      "type": "roundtrip",
      "input": -140737488355328
    },
    {
      "name": "roundtrip_sint56_min",
      "type": "roundtrip",
      "input": -36028797018963968
    },
    {
      "//": "=== Decode tolerance tests ===",
      "//note": "Decoders should accept values encoded in larger-than-necessary formats",
      "name": "decode_0_as_sint8",
      "type": "decode",
      "input_bytes": "e4 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_sint16",
      "type": "decode",
      "input_bytes": "e5 00 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_sint32",
      "type": "decode",
      "input_bytes": "e6 00 00 00 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_sint64",
      "type": "decode",
      "input_bytes": "e7 00 00 00 00 00 00 00 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_uint8",
      "type": "decode",
      "input_bytes": "e0 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_uint16",
      "type": "decode",
      "input_bytes": "e1 00 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_uint32",
      "type": "decode",
      "input_bytes": "e2 00 00 00 00",
      "expected_value": 0
    },
    {
      "name": "decode_0_as_uint64",
      "type": "decode",
      "input_bytes": "e3 00 00 00 00 00 00 00 00",
      "expected_value": 0
    },
    {
      "//": "Small value in larger format",
      "name": "decode_1_as_sint64",
      "type": "decode",
      "input_bytes": "e7 01 00 00 00 00 00 00 00",
      "expected_value": 1
    },
    {
      "//": "Negative value in larger format",
      "name": "decode_neg1_as_sint64",
      "type": "decode",
      "input_bytes": "e7 ff ff ff ff ff ff ff ff",
      "expected_value": -1
    },
    {
      "//": "100 encoded as sint16 (could fit in small int)",
      "name": "decode_100_as_sint16",
      "type": "decode",
      "input_bytes": "e5 64 00",
      "expected_value": 100
    },
    {
      "//": "-100 encoded as sint16 (could fit in small int)",
      "name": "decode_neg100_as_sint16",
      "type": "decode",
      "input_bytes": "e5 9c ff",
      "expected_value": -100
    },
    {
      "//": "=== Encoding alternatives: decoders MUST accept any valid encoding ===",
      "//note": "Per spec: Decoders MUST accept any valid numeric encoding, even if not most compact"
    },
    {
      "//": "127 encoded as uint8 (valid alternative to sint8)",
      "name": "decode_127_as_uint8",
      "type": "decode",
      "input_bytes": "e0 7f",
      "expected_value": 127
    },
    {
      "//": "127 encoded as sint16 (non-minimal but valid)",
      "name": "decode_127_as_sint16",
      "type": "decode",
      "input_bytes": "e5 7f 00",
      "expected_value": 127
    },
    {
      "//": "127 encoded as uint16 (non-minimal but valid)",
      "name": "decode_127_as_uint16",
      "type": "decode",
      "input_bytes": "e1 7f 00",
      "expected_value": 127
    },
    {
      "//": "255 encoded as uint8",
      "name": "decode_255_as_uint8",
      "type": "decode",
      "input_bytes": "e0 ff",
      "expected_value": 255
    },
    {
      "//": "255 encoded as sint16 (must use 2 bytes for signed)",
      "name": "decode_255_as_sint16",
      "type": "decode",
      "input_bytes": "e5 ff 00",
      "expected_value": 255
    },
    {
      "//": "255 encoded as uint16 (non-minimal but valid)",
      "name": "decode_255_as_uint16",
      "type": "decode",
      "input_bytes": "e1 ff 00",
      "expected_value": 255
    },
    {
      "//": "32767 encoded as uint16 (valid alternative to sint16)",
      "name": "decode_32767_as_uint16",
      "type": "decode",
      "input_bytes": "e1 ff 7f",
      "expected_value": 32767
    },
    {
      "//": "32767 encoded as sint32 (non-minimal but valid)",
      "name": "decode_32767_as_sint32",
      "type": "decode",
      "input_bytes": "e6 ff 7f 00 00",
      "expected_value": 32767
    },
    {
      "//": "128 encoded as uint8 (smallest format for this value)",
      "name": "decode_128_as_uint8",
      "type": "decode",
      "input_bytes": "e0 80",
      "expected_value": 128
    },
    {
      "//": "128 encoded as sint16 (needs 2 bytes for signed)",
      "name": "decode_128_as_sint16",
      "type": "decode",
      "input_bytes": "e5 80 00",
      "expected_value": 128
    },
    {
      "//": "-128 encoded as sint8 (minimum sint8 value)",
      "name": "decode_neg128_as_sint8",
      "type": "decode",
      "input_bytes": "e4 80",
      "expected_value": -128
    },
    {
      "//": "-128 encoded as sint16 (non-minimal but valid)",
      "name": "decode_neg128_as_sint16",
      "type": "decode",
      "input_bytes": "e5 80 ff",
      "expected_value": -128
    },
    {
      "//": "-129 encoded as sint16 (just beyond sint8 range)",
      "name": "decode_neg129_as_sint16",
      "type": "decode",
      "input_bytes": "e5 7f ff",
      "expected_value": -129
    },
    {
      "//": "-129 encoded as sint32 (non-minimal but valid)",
      "name": "decode_neg129_as_sint32",
      "type": "decode",
      "input_bytes": "e6 7f ff ff ff",
      "expected_value": -129
    }
  ]
}

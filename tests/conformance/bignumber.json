{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "BigNumber encoding tests for values that cannot be represented as IEEE 754 floats",
  "//note": "BigNumber uses zigzag LEB128 metadata and little-endian magnitude bytes. Wire format: 0x8F + zigzag_leb128(exponent) + zigzag_leb128(signed_length) + magnitude_bytes. signed_length encodes both the sign and byte count of the magnitude. Negative zero is not representable as bignum (use IEEE754 float).",
  "tests": [
    {
      "//": "=== BigNumber zero encoding ===",
      "//note": "Zero: exponent=0 (0x00), signed_length=0 (0x00), no magnitude bytes",
      "name": "decode_bignumber_zero",
      "type": "decode",
      "input_bytes": "b20000",
      "expected_value": 0
    },
    {
      "//": "=== High precision decimals (roundtrip) ===",
      "//note": "These values exceed float64 precision and require arbitrary precision support to roundtrip"
    },
    {
      "//": "19 significant digits - exceeds float64 precision",
      "name": "roundtrip_bignumber_19_digits",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative 19-digit decimal",
      "name": "roundtrip_bignumber_neg_19_digits",
      "type": "roundtrip",
      "input": {
        "$number": "-1.234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "19 digits with negative exponent within common range",
      "name": "roundtrip_bignumber_19_digits_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789e-50"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Pi to 19 digits - exceeds float64 precision",
      "name": "roundtrip_bignumber_pi_19",
      "type": "roundtrip",
      "input": {
        "$number": "3.141592653589793238"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "=== High precision decimals requiring arbitrary precision (roundtrip) ===",
      "//note": "These values have more precision than 64-bit significand can represent"
    },
    {
      "//": "30 significant digits - requires arbitrary precision",
      "name": "bignumber_high_precision",
      "type": "roundtrip",
      "input": {
        "$number": "1.23456789012345678901234567890"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Very small exponent beyond float64 range",
      "name": "bignumber_tiny_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "1e-1000"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "Negative exponent within float64 range but high precision",
      "name": "roundtrip_bignumber_30_digits_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.23456789012345678901234567890e-50"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Many decimal places",
      "name": "roundtrip_bignumber_many_decimals",
      "type": "roundtrip",
      "input": {
        "$number": "0.123456789012345678901234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Value that looks like it could be float64 but has too many sig digits",
      "name": "roundtrip_bignumber_looks_like_float",
      "type": "roundtrip",
      "input": {
        "$number": "3.141592653589793238462643383279"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "=== Negative BigNumber tests ===",
      "//note": "Negative integer within int64 range"
    },
    {
      "name": "roundtrip_bignumber_negative",
      "type": "roundtrip",
      "input": {
        "$number": "-9007199254740993"
      }
    },
    {
      "//": "Negative high precision decimal (requires arbitrary precision)",
      "name": "roundtrip_bignumber_negative_decimal",
      "type": "roundtrip",
      "input": {
        "$number": "-1.23456789012345678901234567890"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative with tiny exponent",
      "name": "roundtrip_bignumber_negative_tiny_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "-1e-500"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== BigNumber zero roundtrip ===",
      "name": "roundtrip_bignumber_zero",
      "type": "roundtrip",
      "input": {
        "$number": "0"
      }
    },
    {
      "//": "=== BigNumber with negative exponent within common range ===",
      "name": "roundtrip_bignumber_small_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.5e-100"
      }
    },
    {
      "//": "Small value with negative exponent requiring extended range",
      "name": "roundtrip_bignumber_precise_small",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789e-200"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== Large exponent tests ===",
      "//note": "Values with large exponents that require BigNumber encoding"
    },
    {
      "//": "Large negative exponent",
      "name": "roundtrip_bignumber_large_negative_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "1e-1000"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== Values at float64 boundary ===",
      "//note": "Values that are just beyond float64 precision"
    },
    {
      "name": "roundtrip_bignumber_beyond_float64_precision",
      "type": "roundtrip",
      "input": {
        "$number": "9007199254740993"
      }
    },
    {
      "//": "Negative value beyond float64 precision",
      "name": "roundtrip_bignumber_negative_beyond_float64",
      "type": "roundtrip",
      "input": {
        "$number": "-9007199254740993"
      }
    },
    {
      "//": "=== BigNumber wire format tests ===",
      "//note": "Wire format: type_code(0x8F) + zigzag_leb128(exponent) + zigzag_leb128(signed_length) + magnitude_bytes"
    },
    {
      "//": "Zero exponent, significand=1: exponent=0, signed_length=+1→zigzag(1)=0x02, magnitude=0x01",
      "name": "decode_bignumber_zero_exponent",
      "type": "decode",
      "input_bytes": "b2000201",
      "expected_value": 1
    },
    {
      "//": "=== Exponent boundary tests ===",
      "//note": "Zigzag LEB128 has no fixed-size boundaries, but we test various exponent values"
    },
    {
      "//": "Max 1-byte exponent: 63 (zigzag(63)=126=0x7E, fits in 1 LEB128 byte)",
      "name": "roundtrip_bignumber_exp_127",
      "type": "roundtrip",
      "input": {
        "$number": "1e127"
      }
    },
    {
      "//": "Min 1-byte exponent: -64 (zigzag(-64)=127=0x7F, fits in 1 LEB128 byte)",
      "name": "roundtrip_bignumber_exp_neg128",
      "type": "roundtrip",
      "input": {
        "$number": "1e-128"
      }
    },
    {
      "//": "First value requiring 2-byte LEB128 exponent: 128 (zigzag(128)=256)",
      "name": "roundtrip_bignumber_exp_128",
      "type": "roundtrip",
      "input": {
        "$number": "1e128"
      },
      "requires": [
        "bignumber_exponent_gt_127"
      ]
    },
    {
      "//": "First negative value requiring 2-byte LEB128 exponent: -129",
      "name": "roundtrip_bignumber_exp_neg129",
      "type": "roundtrip",
      "input": {
        "$number": "1e-129"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "Value requiring 2-byte LEB128 exponent: 200",
      "name": "roundtrip_bignumber_exp_200",
      "type": "roundtrip",
      "input": {
        "$number": "1e200"
      },
      "requires": [
        "bignumber_exponent_gt_127"
      ]
    },
    {
      "//": "Large negative exponent requiring 2-byte LEB128 encoding: -200",
      "name": "roundtrip_bignumber_exp_neg200",
      "type": "roundtrip",
      "input": {
        "$number": "1e-200"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== Significand size tests ===",
      "//note": "Signed length + LE magnitude encoding"
    },
    {
      "//": "Value 255: signed_length=+1→zigzag(1)=0x02, magnitude=0xFF",
      "name": "decode_bignumber_sig_1_byte",
      "type": "decode",
      "input_bytes": "b20002ff",
      "expected_value": 255
    },
    {
      "//": "Value 65535: signed_length=+2→zigzag(2)=0x04, magnitude=0xFFFF LE",
      "name": "decode_bignumber_sig_2_bytes",
      "type": "decode",
      "input_bytes": "b20004ffff",
      "expected_value": 65535
    },
    {
      "//": "Value 65537: signed_length=+3→zigzag(3)=0x06, magnitude=0x010001 LE = 01 00 01",
      "name": "decode_bignumber_sig_3_bytes",
      "type": "decode",
      "input_bytes": "b20006010001",
      "expected_value": 65537
    },
    {
      "//": "Value -255: signed_length=-1→zigzag(-1)=0x01, magnitude=0xFF",
      "name": "decode_bignumber_negative_1_byte",
      "type": "decode",
      "input_bytes": "b20001ff",
      "expected_value": -255
    },
    {
      "//": "Value -65535: signed_length=-2→zigzag(-2)=0x03, magnitude=0xFFFF LE",
      "name": "decode_bignumber_negative_2_bytes",
      "type": "decode",
      "input_bytes": "b20003ffff",
      "expected_value": -65535
    },
    {
      "//": "=== Large significand tests (require arbitrary precision) ===",
      "//note": "Values requiring more than 64-bit significand"
    },
    {
      "//": "Very large significand value",
      "name": "decode_bignumber_max_siglen_small",
      "type": "roundtrip",
      "input": {
        "$number": "1773775876797123091660094745843871137458179912157484130506396813846708481"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Maximum 248-bit value",
      "name": "decode_bignumber_max_siglen_max_value",
      "type": "roundtrip",
      "input": {
        "$number": "452312848583266388373324160190187140051835877600158453279131187530910662655"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative very large significand value",
      "name": "decode_bignumber_max_siglen_negative",
      "type": "roundtrip",
      "input": {
        "$number": "-1773775876797123091660094745843871137458179912157484130506396813846708481"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    }
  ]
}

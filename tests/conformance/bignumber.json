{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "BigNumber encoding tests for values that cannot be represented as IEEE 754 floats",
  "//note": "BigNumber uses zigzag LEB128 metadata and little-endian magnitude bytes. Wire format: 0xCA + zigzag_leb128(exponent) + zigzag_leb128(signed_length) + magnitude_bytes. signed_length encodes both the sign and byte count of the magnitude. Negative zero is not representable as bignum (use IEEE754 float).",
  "tests": [
    {
      "//": "=== BigNumber zero encoding ===",
      "//note": "Zero: exponent=0 (0x00), signed_length=0 (0x00), no magnitude bytes",
      "name": "decode_bignumber_zero",
      "type": "decode",
      "input_bytes": "ca 00 00",
      "expected_value": 0
    },
    {
      "//": "=== High precision decimals (roundtrip) ===",
      "//note": "These values exceed float64 precision and require arbitrary precision support to roundtrip"
    },
    {
      "//": "19 significant digits - exceeds float64 precision",
      "name": "roundtrip_bignumber_19_digits",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative 19-digit decimal",
      "name": "roundtrip_bignumber_neg_19_digits",
      "type": "roundtrip",
      "input": {
        "$number": "-1.234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "19 digits with negative exponent within common range",
      "name": "roundtrip_bignumber_19_digits_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789e-50"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Pi to 19 digits - exceeds float64 precision",
      "name": "roundtrip_bignumber_pi_19",
      "type": "roundtrip",
      "input": {
        "$number": "3.141592653589793238"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "=== High precision decimals requiring arbitrary precision (roundtrip) ===",
      "//note": "These values have more precision than 64-bit significand can represent"
    },
    {
      "//": "30 significant digits - requires arbitrary precision",
      "name": "bignumber_high_precision",
      "type": "roundtrip",
      "input": {
        "$number": "1.23456789012345678901234567890"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Very small exponent beyond float64 range",
      "name": "bignumber_tiny_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "1e-1000"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "Negative exponent within float64 range but high precision",
      "name": "roundtrip_bignumber_30_digits_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.23456789012345678901234567890e-50"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Many decimal places",
      "name": "roundtrip_bignumber_many_decimals",
      "type": "roundtrip",
      "input": {
        "$number": "0.123456789012345678901234567890123456789"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Value that looks like it could be float64 but has too many sig digits",
      "name": "roundtrip_bignumber_looks_like_float",
      "type": "roundtrip",
      "input": {
        "$number": "3.141592653589793238462643383279"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "=== Negative BigNumber tests ==="
    },
    {
      "//": "Negative high precision decimal (requires arbitrary precision)",
      "name": "roundtrip_bignumber_negative_decimal",
      "type": "roundtrip",
      "input": {
        "$number": "-1.23456789012345678901234567890"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative with tiny exponent",
      "name": "roundtrip_bignumber_negative_tiny_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "-1e-500"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== BigNumber zero roundtrip ===",
      "name": "roundtrip_bignumber_zero",
      "type": "roundtrip",
      "input": {
        "$number": "0"
      }
    },
    {
      "//": "=== BigNumber with negative exponent within common range ===",
      "name": "roundtrip_bignumber_small_neg_exp",
      "type": "roundtrip",
      "input": {
        "$number": "1.5e-100"
      }
    },
    {
      "//": "Small value with negative exponent requiring extended range",
      "name": "roundtrip_bignumber_precise_small",
      "type": "roundtrip",
      "input": {
        "$number": "1.234567890123456789e-200"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== Large exponent tests ===",
      "//note": "Values with large exponents that require BigNumber encoding"
    },
    {
      "//": "Large negative exponent",
      "name": "roundtrip_bignumber_large_negative_exponent",
      "type": "roundtrip",
      "input": {
        "$number": "1e-1000"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== BigNumber wire format tests ===",
      "//note": "Wire format: type_code(0xCA) + zigzag_leb128(exponent) + zigzag_leb128(signed_length) + magnitude_bytes"
    },
    {
      "//": "Zero exponent, significand=1: exponent=0, signed_length=+1→zigzag(1)=0x02, magnitude=0x01",
      "name": "decode_bignumber_zero_exponent",
      "type": "decode",
      "input_bytes": "ca 00 02 01",
      "expected_value": 1
    },
    {
      "//": "=== Exponent boundary tests ===",
      "//note": "Zigzag LEB128 has no fixed-size boundaries, but we test various exponent values"
    },
    {
      "//": "Max 1-byte exponent: 63 (zigzag(63)=126=0x7E, fits in 1 LEB128 byte)",
      "name": "roundtrip_bignumber_exp_127",
      "type": "roundtrip",
      "input": {
        "$number": "1e127"
      }
    },
    {
      "//": "Min 1-byte exponent: -64 (zigzag(-64)=127=0x7F, fits in 1 LEB128 byte)",
      "name": "roundtrip_bignumber_exp_neg128",
      "type": "roundtrip",
      "input": {
        "$number": "1e-128"
      }
    },
    {
      "//": "First value requiring 2-byte LEB128 exponent: 128 (zigzag(128)=256)",
      "name": "roundtrip_bignumber_exp_128",
      "type": "roundtrip",
      "input": {
        "$number": "1e128"
      },
      "requires": [
        "bignumber_exponent_gt_127"
      ]
    },
    {
      "//": "First negative value requiring 2-byte LEB128 exponent: -129",
      "name": "roundtrip_bignumber_exp_neg129",
      "type": "roundtrip",
      "input": {
        "$number": "1e-129"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "Value requiring 2-byte LEB128 exponent: 200",
      "name": "roundtrip_bignumber_exp_200",
      "type": "roundtrip",
      "input": {
        "$number": "1e200"
      },
      "requires": [
        "bignumber_exponent_gt_127"
      ]
    },
    {
      "//": "Large negative exponent requiring 2-byte LEB128 encoding: -200",
      "name": "roundtrip_bignumber_exp_neg200",
      "type": "roundtrip",
      "input": {
        "$number": "1e-200"
      },
      "requires": [
        "bignumber_exponent_lt_neg128"
      ]
    },
    {
      "//": "=== Significand size tests ===",
      "//note": "Signed length + LE magnitude encoding"
    },
    {
      "//": "Value 255: signed_length=+1→zigzag(1)=0x02, magnitude=0xFF",
      "name": "decode_bignumber_sig_1_byte",
      "type": "decode",
      "input_bytes": "ca 00 02 ff",
      "expected_value": 255
    },
    {
      "//": "Value 65535: signed_length=+2→zigzag(2)=0x04, magnitude=0xFFFF LE",
      "name": "decode_bignumber_sig_2_bytes",
      "type": "decode",
      "input_bytes": "ca 00 04 ff ff",
      "expected_value": 65535
    },
    {
      "//": "Value 65537: signed_length=+3→zigzag(3)=0x06, magnitude=0x010001 LE = 01 00 01",
      "name": "decode_bignumber_sig_3_bytes",
      "type": "decode",
      "input_bytes": "ca 00 06 01 00 01",
      "expected_value": 65537
    },
    {
      "//": "Value -255: signed_length=-1→zigzag(-1)=0x01, magnitude=0xFF",
      "name": "decode_bignumber_negative_1_byte",
      "type": "decode",
      "input_bytes": "ca 00 01 ff",
      "expected_value": -255
    },
    {
      "//": "Value -65535: signed_length=-2→zigzag(-2)=0x03, magnitude=0xFFFF LE",
      "name": "decode_bignumber_negative_2_bytes",
      "type": "decode",
      "input_bytes": "ca 00 03 ff ff",
      "expected_value": -65535
    },
    {
      "//": "=== Large significand tests (require arbitrary precision) ===",
      "//note": "Values requiring more than 64-bit significand"
    },
    {
      "//": "Very large significand value",
      "name": "decode_bignumber_max_siglen_small",
      "type": "roundtrip",
      "input": {
        "$number": "1773775876797123091660094745843871137458179912157484130506396813846708481"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Maximum 248-bit value",
      "name": "decode_bignumber_max_siglen_max_value",
      "type": "roundtrip",
      "input": {
        "$number": "452312848583266388373324160190187140051835877600158453279131187530910662655"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "Negative very large significand value",
      "name": "decode_bignumber_max_siglen_negative",
      "type": "roundtrip",
      "input": {
        "$number": "-1773775876797123091660094745843871137458179912157484130506396813846708481"
      },
      "requires": [
        "arbitrary_precision_bignumber"
      ]
    },
    {
      "//": "=== Non-zero exponent decode tests ===",
      "//note": "Verify exact zigzag LEB128 encoding of exponent field with known byte sequences"
    },
    {
      "//": "Value 2: exponent=0→zigzag(0)=0x00, signed_length=+1→zigzag(1)=0x02, magnitude=0x02",
      "name": "decode_bignumber_value_2",
      "type": "decode",
      "input_bytes": "ca 00 02 02",
      "expected_value": 2
    },
    {
      "//": "Value -1: exponent=0→zigzag(0)=0x00, signed_length=-1→zigzag(-1)=0x01, magnitude=0x01",
      "name": "decode_bignumber_negative_1",
      "type": "decode",
      "input_bytes": "ca 00 01 01",
      "expected_value": -1
    },
    {
      "//": "Value 1.5 (15×10⁻¹): exponent=-1→zigzag(-1)=0x01, signed_length=+1→zigzag(1)=0x02, magnitude=0x0F",
      "name": "decode_bignumber_decimal_1_5",
      "type": "decode",
      "input_bytes": "ca 01 02 0f",
      "expected_value": 1.5
    },
    {
      "//": "Value 1000 (10×10²): exponent=2→zigzag(2)=0x04, signed_length=+1→zigzag(1)=0x02, magnitude=0x0A",
      "name": "decode_bignumber_value_1000",
      "type": "decode",
      "input_bytes": "ca 04 02 0a",
      "expected_value": 1000
    },
    {
      "//": "Value -1000 (-10×10²): exponent=2→zigzag(2)=0x04, signed_length=-1→zigzag(-1)=0x01, magnitude=0x0A",
      "name": "decode_bignumber_neg_1000",
      "type": "decode",
      "input_bytes": "ca 04 01 0a",
      "expected_value": -1000
    },
    {
      "//": "Value 100000 (1×10⁵): exponent=5→zigzag(5)=0x0A, signed_length=+1→zigzag(1)=0x02, magnitude=0x01",
      "name": "decode_bignumber_value_100000",
      "type": "decode",
      "input_bytes": "ca 0a 02 01",
      "expected_value": 100000
    },
    {
      "//": "=== Zigzag LEB128 exponent encoding boundary tests ===",
      "//note": "1-byte zigzag LEB128 holds zigzag values 0-127, so max 1-byte positive exponent is 63 (zigzag=126) and max 1-byte negative exponent is -64 (zigzag=127)"
    },
    {
      "//": "Exponent 63: zigzag(63)=126=0x7E, max 1-byte positive exponent. sig=1, value=10^63",
      "name": "decode_bignumber_exp_63_max_1byte_positive",
      "type": "decode",
      "input_bytes": "ca 7e 02 01",
      "expected_value": {"$number": "1000000000000000000000000000000000000000000000000000000000000000"},
      "requires": ["arbitrary_precision_bignumber"]
    },
    {
      "//": "Exponent -64: zigzag(-64)=127=0x7F, last 1-byte negative exponent",
      "name": "roundtrip_bignumber_exp_neg64_max_1byte_negative",
      "type": "roundtrip",
      "input": {"$number": "1e-64"}
    },
    {
      "//": "Exponent 64: zigzag(64)=128, LEB128=0x80 0x01. First 2-byte positive exponent. sig=1, value=10^64",
      "name": "decode_bignumber_exp_64_first_2byte_positive",
      "type": "decode",
      "input_bytes": "ca 80 01 02 01",
      "expected_value": {"$number": "10000000000000000000000000000000000000000000000000000000000000000"},
      "requires": ["arbitrary_precision_bignumber"]
    },
    {
      "//": "Exponent -65: zigzag(-65)=129, LEB128=0x81 0x01. First 2-byte negative exponent",
      "name": "roundtrip_bignumber_exp_neg65_first_2byte_negative",
      "type": "roundtrip",
      "input": {"$number": "1e-65"}
    },
    {
      "//": "Encode 10^20 as BigNumber (outside int64 range)",
      "//note": "sig=1, exp=20 (zigzag=40=0x28), signed_len=+1 (zigzag=2=0x02), magnitude=0x01",
      "name": "encode_bignumber_10e20",
      "type": "encode",
      "input": {"$number": "100000000000000000000"},
      "expected_bytes": "ca 28 02 01"
    },
    {
      "//": "Encode -10^20 as BigNumber",
      "//note": "sig=-1, exp=20, signed_len=-1 (zigzag=1=0x01), magnitude=0x01",
      "name": "encode_bignumber_neg_10e20",
      "type": "encode",
      "input": {"$number": "-100000000000000000000"},
      "expected_bytes": "ca 28 01 01"
    },
    {
      "//": "Encode 2^64 as BigNumber (not divisible by 10)",
      "//note": "sig=2^64, exp=0. Magnitude = 0x10000000000000000 = 9 bytes LE. signed_len=+9 (zigzag=18=0x12), exp=0 (zigzag=0=0x00)",
      "name": "encode_bignumber_2_pow_64",
      "type": "encode",
      "input": {"$number": "18446744073709551616"},
      "expected_bytes": "ca 00 12 00 00 00 00 00 00 00 00 01"
    }
  ]
}

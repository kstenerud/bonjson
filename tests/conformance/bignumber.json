{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "BigNumber encoding tests for values that cannot be represented as IEEE 754 floats",
  "//note": "BigNumber roundtrip tests may decode to different types (big.Int, big.Float, float64, string) depending on the implementation. These tests verify the value survives encoding/decoding, not the specific type returned.",
  "tests": [
    {
      "//": "=== BigNumber zero encoding ===",
      "//note": "BigNumber zero has sigLen=0, special value=0 (header byte 0x00)",
      "name": "decode_bignumber_zero",
      "type": "decode",
      "input_bytes": "6900",
      "expected_value": 0
    },
    {
      "//": "=== High precision decimals (roundtrip) ===",
      "//note": "These values have more precision than float64 can represent exactly",
      "name": "bignumber_high_precision",
      "type": "roundtrip",
      "input": {"$number": "1.23456789012345678901234567890"}
    },
    {
      "//": "Very small exponent beyond float64 range",
      "name": "bignumber_tiny_exponent",
      "type": "roundtrip",
      "input": {"$number": "1e-1000"}
    },
    {
      "//": "Negative exponent within float64 range but high precision",
      "name": "roundtrip_bignumber_negative_exponent",
      "type": "roundtrip",
      "input": {"$number": "1.23456789012345678901234567890e-50"}
    },
    {
      "//": "Many decimal places",
      "name": "roundtrip_bignumber_many_decimals",
      "type": "roundtrip",
      "input": {"$number": "0.123456789012345678901234567890123456789"}
    },
    {
      "//": "Value that looks like it could be float64 but has too many sig digits",
      "name": "roundtrip_bignumber_looks_like_float",
      "type": "roundtrip",
      "input": {"$number": "3.141592653589793238462643383279"}
    },
    {
      "//": "=== Negative BigNumber tests ===",
      "//note": "Negative integer within int64 range",
      "name": "roundtrip_bignumber_negative",
      "type": "roundtrip",
      "input": {"$number": "-9007199254740993"}
    },
    {
      "//": "Negative high precision decimal",
      "name": "roundtrip_bignumber_negative_decimal",
      "type": "roundtrip",
      "input": {"$number": "-1.23456789012345678901234567890"}
    },
    {
      "//": "Negative with tiny exponent",
      "name": "roundtrip_bignumber_negative_tiny_exponent",
      "type": "roundtrip",
      "input": {"$number": "-1e-500"}
    },
    {
      "//": "=== BigNumber zero roundtrip ===",
      "name": "roundtrip_bignumber_zero",
      "type": "roundtrip",
      "input": {"$number": "0"}
    },
    {
      "//": "=== BigNumber with negative exponent ===",
      "name": "roundtrip_bignumber_negative_exponent",
      "type": "roundtrip",
      "input": {"$number": "1.5e-100"}
    },
    {
      "//": "Small value with negative exponent requiring BigNumber precision",
      "name": "roundtrip_bignumber_precise_small",
      "type": "roundtrip",
      "input": {"$number": "1.234567890123456789e-200"}
    },
    {
      "//": "=== Large exponent tests ===",
      "//note": "Values with large exponents that require BigNumber encoding",
      "//note2": "Tests like 1e1000 are removed as they overflow float64 when decoded to interface{}"
    },
    {
      "//": "Large negative exponent",
      "name": "roundtrip_bignumber_large_negative_exponent",
      "type": "roundtrip",
      "input": {"$number": "1e-1000"}
    },
    {
      "//": "=== Values at float64 boundary ===",
      "//note": "Values that are just beyond float64 precision",
      "name": "roundtrip_bignumber_beyond_float64_precision",
      "type": "roundtrip",
      "input": {"$number": "9007199254740993"}
    },
    {
      "//": "Negative value beyond float64 precision",
      "name": "roundtrip_bignumber_negative_beyond_float64",
      "type": "roundtrip",
      "input": {"$number": "-9007199254740993"}
    }
  ]
}

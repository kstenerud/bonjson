{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "Attack string tests: bytes 0xFC-0xFF in string data. These bytes are invalid UTF-8 and must be rejected by decoders.",
  "tests": [
    {
      "//": "=== Structural bytes in short strings (invalid UTF-8) ==="
    },
    {
      "//": "0xFC (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fc_only",
      "type": "decode_error",
      "input_bytes": "66fc",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fd_only",
      "type": "decode_error",
      "input_bytes": "66fd",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fe_only",
      "type": "decode_error",
      "input_bytes": "66fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF (invalid UTF-8) as sole byte in short string",
      "name": "short_string_ff_only",
      "type": "decode_error",
      "input_bytes": "66ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "6861fc62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "6861fd62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "6861fe62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF between valid ASCII in short string",
      "name": "short_string_ff_middle",
      "type": "decode_error",
      "input_bytes": "6861ff62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes in one short string",
      "name": "short_string_all_structural_bytes",
      "type": "decode_error",
      "input_bytes": "69fcfdfeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) at start of multi-byte short string",
      "name": "short_string_fc_start",
      "type": "decode_error",
      "input_bytes": "68fc6162",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) at end of multi-byte short string",
      "name": "short_string_fe_end",
      "type": "decode_error",
      "input_bytes": "686162fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in long strings (invalid UTF-8) ===",
      "//note": "Long strings are FF-terminated. Bytes FC/FD/FE are valid data bytes within a long string (only FF terminates), but they are invalid UTF-8."
    },
    {
      "//": "0xFC (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fc_only",
      "type": "decode_error",
      "input_bytes": "fffcff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fd_only",
      "type": "decode_error",
      "input_bytes": "fffdff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fe_only",
      "type": "decode_error",
      "input_bytes": "fffeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "ff61fc62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "ff61fd62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "ff61fe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes as long string data (only FC/FD/FE survive; FF terminates early)",
      "//note": "FF 61 FC FD FE 62 FF = long string 'a\\xFC\\xFD\\xFE b'",
      "name": "long_string_three_structural_bytes",
      "type": "decode_error",
      "input_bytes": "ff61fcfdfe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) at start of long string data",
      "name": "long_string_fc_start",
      "type": "decode_error",
      "input_bytes": "fffc6162ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) at end of long string data (just before FF terminator)",
      "name": "long_string_fe_before_terminator",
      "type": "decode_error",
      "input_bytes": "ff6162feff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in strings inside containers ===",
      "//note": "These test that the decoder correctly rejects invalid UTF-8 bytes (0xFC-0xFF) inside string data."
    },
    {
      "//": "Array containing long string with 0xFE data byte (invalid UTF-8)",
      "//note": "FC FF FE FF FE = array( long_string('\\xFE') ) — structurally valid, but string is invalid UTF-8",
      "name": "array_long_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b4fffeffb3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing short string with 0xFE data byte (invalid UTF-8)",
      "//note": "FC D1 FE FE = array( short_string('\\xFE') )",
      "name": "array_short_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b466feb3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFC data byte (invalid UTF-8)",
      "//note": "FC FF FC FF FE = array( long_string('\\xFC') )",
      "name": "array_long_string_with_fc_byte",
      "type": "decode_error",
      "input_bytes": "b4fffcffb3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFD data byte (invalid UTF-8)",
      "//note": "FC FF FD FF FE = array( long_string('\\xFD') )",
      "name": "array_long_string_with_fd_byte",
      "type": "decode_error",
      "input_bytes": "b4fffdffb3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFC (invalid UTF-8, short string)",
      "//note": "FD D1 FC 64 FE = object( key='\\xFC', value=0 )",
      "name": "object_key_short_string_with_fc",
      "type": "decode_error",
      "input_bytes": "b566fc00b3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFE (invalid UTF-8, long string)",
      "//note": "FD FF FE FF 64 FE = object( key='\\xFE', value=0 )",
      "name": "object_key_long_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b5fffeff00b3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object value containing 0xFD (invalid UTF-8, long string)",
      "//note": "FD D1 61 FF FD FF FE = object( key='a', value='\\xFD' )",
      "name": "object_value_long_string_with_fd",
      "type": "decode_error",
      "input_bytes": "b56661fffdffb3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Nested: array in object value, inner string has FE",
      "//note": "FD D1 61 FC D1 FE FE FE = object( key='a', value=array( short_string('\\xFE') ) )",
      "name": "nested_object_array_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b56661b466feb3b3",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural confusion: premature FF termination ===",
      "//note": "When a long string's data is truncated (no FF terminator found), the decoder must report truncation, not silently misparse."
    },
    {
      "//": "Long string data contains only FE, no FF terminator — FE is data, not terminator",
      "//note": "FF 61 62 FE (no terminating FF) → truncated",
      "name": "long_string_unterminated_with_fe",
      "type": "decode_error",
      "input_bytes": "ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FE (invalid UTF-8) but no FF terminator",
      "//note": "FC FF 61 62 FE (no FF) → truncated",
      "name": "long_string_in_array_unterminated_fe",
      "type": "decode_error",
      "input_bytes": "b4ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FC (invalid UTF-8) but no FF terminator",
      "name": "long_string_in_array_unterminated_fc",
      "type": "decode_error",
      "input_bytes": "b4ff6162fc",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FD (invalid UTF-8) but no FF terminator",
      "name": "long_string_in_array_unterminated_fd",
      "type": "decode_error",
      "input_bytes": "b4ff6162fd",
      "expected_error": "truncated"
    },
    {
      "//": "=== Valid structural parsing near string boundaries ===",
      "//note": "These are NOT error tests. They verify correct parsing when structural bytes (used properly) surround strings."
    },
    {
      "//": "Empty long string in array: FC FF FF FE",
      "name": "valid_empty_long_string_in_array",
      "type": "decode",
      "input_bytes": "b4ffffb3",
      "expected_value": [
        ""
      ]
    },
    {
      "//": "Two consecutive long strings in array: FC FF 61 FF FF 62 FF FE",
      "name": "valid_two_long_strings_in_array",
      "type": "decode",
      "input_bytes": "b4ff61ffff62ffb3",
      "expected_value": [
        "a",
        "b"
      ]
    },
    {
      "//": "Long string value in object: FD D1 61 FF 62 FF FE",
      "name": "valid_long_string_value_in_object",
      "type": "decode",
      "input_bytes": "b56661ff62ffb3",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Long string key and value in object: FD FF 61 FF FF 62 FF FE",
      "name": "valid_long_string_key_and_value",
      "type": "decode",
      "input_bytes": "b5ff61ffff62ffb3",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Empty long string as object key: FD FF FF 64 FE",
      "name": "valid_empty_long_string_key",
      "type": "decode",
      "input_bytes": "b5ffff00b3",
      "expected_value": {
        "": 0
      }
    },
    {
      "//": "Array with mix of short and long strings: FC D1 61 FF 62 FF D1 63 FE",
      "name": "valid_mixed_short_long_strings",
      "type": "decode",
      "input_bytes": "b46661ff62ff6663b3",
      "expected_value": [
        "a",
        "b",
        "c"
      ]
    },
    {
      "//": "Nested arrays with long strings: FC FC FF 61 FF FE FC FF 62 FF FE FE",
      "name": "valid_nested_arrays_with_long_strings",
      "type": "decode",
      "input_bytes": "b4b4ff61ffb3b4ff62ffb3b3",
      "expected_value": [
        [
          "a"
        ],
        [
          "b"
        ]
      ]
    },
    {
      "//": "Deeply nested container with long string leaf: FC FC FC FF 78 FF FE FE FE",
      "name": "valid_deeply_nested_long_string",
      "type": "decode",
      "input_bytes": "b4b4b4ff78ffb3b3b3",
      "expected_value": [
        [
          [
            "x"
          ]
        ]
      ]
    },
    {
      "//": "Object containing array containing long string with FE-adjacent bytes (0xFB is valid)",
      "//note": "0xFB is typed array uint64. It's invalid UTF-8, so we use 0x7B ('{') which is the last valid ASCII byte before the 0xFC-0xFF range",
      "name": "valid_string_with_high_ascii_in_nested",
      "type": "decode",
      "input_bytes": "b56661b4ff7b7dffb3b3",
      "expected_value": {
        "a": [
          "{}"
        ]
      }
    }
  ]
}

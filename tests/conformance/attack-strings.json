{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "Attack string tests: bytes 0xFC-0xFF in string data. These bytes are invalid UTF-8 and must be rejected by decoders.",
  "tests": [
    {
      "//": "=== Structural bytes in short strings (invalid UTF-8) ==="
    },
    {
      "//": "0xFC (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fc_only",
      "type": "decode_error",
      "input_bytes": "66fc",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fd_only",
      "type": "decode_error",
      "input_bytes": "66fd",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) as sole byte in short string",
      "name": "short_string_fe_only",
      "type": "decode_error",
      "input_bytes": "66fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF (invalid UTF-8) as sole byte in short string",
      "name": "short_string_ff_only",
      "type": "decode_error",
      "input_bytes": "66ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "6861fc62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "6861fd62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) between valid ASCII in short string",
      "name": "short_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "6861fe62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF between valid ASCII in short string",
      "name": "short_string_ff_middle",
      "type": "decode_error",
      "input_bytes": "6861ff62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes in one short string",
      "name": "short_string_all_structural_bytes",
      "type": "decode_error",
      "input_bytes": "69fcfdfeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) at start of multi-byte short string",
      "name": "short_string_fc_start",
      "type": "decode_error",
      "input_bytes": "68fc6162",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) at end of multi-byte short string",
      "name": "short_string_fe_end",
      "type": "decode_error",
      "input_bytes": "686162fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in long strings (invalid UTF-8) ===",
      "//note": "Long strings are FF-terminated. Bytes FC/FD/FE are valid data bytes within a long string (only FF terminates), but they are invalid UTF-8."
    },
    {
      "//": "0xFC (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fc_only",
      "type": "decode_error",
      "input_bytes": "fffcff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fd_only",
      "type": "decode_error",
      "input_bytes": "fffdff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) as sole data byte in long string",
      "name": "long_string_fe_only",
      "type": "decode_error",
      "input_bytes": "fffeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "ff61fc62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "ff61fd62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) between ASCII in long string",
      "name": "long_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "ff61fe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes as long string data (only FC/FD/FE survive; FF terminates early)",
      "//note": "FF 61 FC FD FE 62 FF = long string 'a\\xFC\\xFD\\xFE b'",
      "name": "long_string_three_structural_bytes",
      "type": "decode_error",
      "input_bytes": "ff61fcfdfe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC (invalid UTF-8) at start of long string data",
      "name": "long_string_fc_start",
      "type": "decode_error",
      "input_bytes": "fffc6162ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (invalid UTF-8) at end of long string data (just before FF terminator)",
      "name": "long_string_fe_before_terminator",
      "type": "decode_error",
      "input_bytes": "ff6162feff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in strings inside containers ===",
      "//note": "These test that the decoder correctly rejects invalid UTF-8 bytes (0xFC-0xFF) inside string data."
    },
    {
      "//": "Array containing long string with 0xFE data byte (invalid UTF-8)",
      "//note": "b7 FF FE FF b6 = array( long_string('\\xFE') ) — structurally valid, but string is invalid UTF-8",
      "name": "array_long_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b7fffeffb6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing short string with 0xFE data byte (invalid UTF-8)",
      "//note": "b7 66 FE b6 = array( short_string('\\xFE') )",
      "name": "array_short_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b766feb6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFC data byte (invalid UTF-8)",
      "//note": "b7 FF FC FF b6 = array( long_string('\\xFC') )",
      "name": "array_long_string_with_fc_byte",
      "type": "decode_error",
      "input_bytes": "b7fffcffb6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFD data byte (invalid UTF-8)",
      "//note": "b7 FF FD FF b6 = array( long_string('\\xFD') )",
      "name": "array_long_string_with_fd_byte",
      "type": "decode_error",
      "input_bytes": "b7fffdffb6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFC (invalid UTF-8, short string)",
      "//note": "b8 66 FC 00 b6 = object( key='\\xFC', value=0 )",
      "name": "object_key_short_string_with_fc",
      "type": "decode_error",
      "input_bytes": "b866fc00b6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFE (invalid UTF-8, long string)",
      "//note": "b8 FF FE FF 00 b6 = object( key='\\xFE', value=0 )",
      "name": "object_key_long_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b8fffeff00b6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object value containing 0xFD (invalid UTF-8, long string)",
      "//note": "b8 66 61 FF FD FF b6 = object( key='a', value='\\xFD' )",
      "name": "object_value_long_string_with_fd",
      "type": "decode_error",
      "input_bytes": "b86661fffdffb6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Nested: array in object value, inner string has FE",
      "//note": "b8 66 61 b7 66 FE b6 b6 = object( key='a', value=array( short_string('\\xFE') ) )",
      "name": "nested_object_array_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b86661b766feb6b6",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural confusion: premature FF termination ===",
      "//note": "When a long string's data is truncated (no FF terminator found), the decoder must report truncation, not silently misparse."
    },
    {
      "//": "Long string data contains only FE, no FF terminator — FE is data, not terminator",
      "//note": "FF 61 62 FE (no terminating FF) → truncated",
      "name": "long_string_unterminated_with_fe",
      "type": "decode_error",
      "input_bytes": "ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FE (invalid UTF-8) but no FF terminator",
      "//note": "b7 FF 61 62 FE (no terminating FF) → truncated",
      "name": "long_string_in_array_unterminated_fe",
      "type": "decode_error",
      "input_bytes": "b7ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FC (invalid UTF-8) but no FF terminator",
      "name": "long_string_in_array_unterminated_fc",
      "type": "decode_error",
      "input_bytes": "b7ff6162fc",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FD (invalid UTF-8) but no FF terminator",
      "name": "long_string_in_array_unterminated_fd",
      "type": "decode_error",
      "input_bytes": "b7ff6162fd",
      "expected_error": "truncated"
    },
    {
      "//": "=== Valid structural parsing near string boundaries ===",
      "//note": "These are NOT error tests. They verify correct parsing when structural bytes (used properly) surround strings."
    },
    {
      "//": "Empty long string in array: b7 FF FF b6",
      "name": "valid_empty_long_string_in_array",
      "type": "decode",
      "input_bytes": "b7ffffb6",
      "expected_value": [
        ""
      ]
    },
    {
      "//": "Two consecutive long strings in array: b7 FF 61 FF FF 62 FF b6",
      "name": "valid_two_long_strings_in_array",
      "type": "decode",
      "input_bytes": "b7ff61ffff62ffb6",
      "expected_value": [
        "a",
        "b"
      ]
    },
    {
      "//": "Long string value in object: b8 66 61 FF 62 FF b6",
      "name": "valid_long_string_value_in_object",
      "type": "decode",
      "input_bytes": "b86661ff62ffb6",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Long string key and value in object: b8 FF 61 FF FF 62 FF b6",
      "name": "valid_long_string_key_and_value",
      "type": "decode",
      "input_bytes": "b8ff61ffff62ffb6",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Empty long string as object key: b8 FF FF 00 b6",
      "name": "valid_empty_long_string_key",
      "type": "decode",
      "input_bytes": "b8ffff00b6",
      "expected_value": {
        "": 0
      }
    },
    {
      "//": "Array with mix of short and long strings: b7 66 61 FF 62 FF 66 63 b6",
      "name": "valid_mixed_short_long_strings",
      "type": "decode",
      "input_bytes": "b76661ff62ff6663b6",
      "expected_value": [
        "a",
        "b",
        "c"
      ]
    },
    {
      "//": "Nested arrays with long strings: b7 b7 FF 61 FF b6 b7 FF 62 FF b6 b6",
      "name": "valid_nested_arrays_with_long_strings",
      "type": "decode",
      "input_bytes": "b7b7ff61ffb6b7ff62ffb6b6",
      "expected_value": [
        [
          "a"
        ],
        [
          "b"
        ]
      ]
    },
    {
      "//": "Deeply nested container with long string leaf: b7 b7 b7 FF 78 FF b6 b6 b6",
      "name": "valid_deeply_nested_long_string",
      "type": "decode",
      "input_bytes": "b7b7b7ff78ffb6b6b6",
      "expected_value": [
        [
          [
            "x"
          ]
        ]
      ]
    },
    {
      "//": "Object containing array containing long string with FE-adjacent bytes (0xFB is valid)",
      "//note": "0xFB is typed array uint64. It's invalid UTF-8, so we use 0x7B ('{') which is the last valid ASCII byte before the 0xFC-0xFF range",
      "name": "valid_string_with_high_ascii_in_nested",
      "type": "decode",
      "input_bytes": "b86661b7ff7b7dffb6b6",
      "expected_value": {
        "a": [
          "{}"
        ]
      }
    }
  ]
}

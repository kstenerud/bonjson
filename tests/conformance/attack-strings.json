{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "Attack string tests: bytes 0xFC-0xFF in string data. These bytes are both structural markers in Phase 2 wire format and invalid UTF-8. Tests verify decoders reject them and don't mis-parse structural boundaries.",
  "tests": [
    {
      "//": "=== Structural bytes in short strings (invalid UTF-8) ==="
    },
    {
      "//": "0xFC (array start) as sole byte in short string",
      "name": "short_string_fc_only",
      "type": "decode_error",
      "input_bytes": "66fc",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD (object start) as sole byte in short string",
      "name": "short_string_fd_only",
      "type": "decode_error",
      "input_bytes": "66fd",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE (container end) as sole byte in short string",
      "name": "short_string_fe_only",
      "type": "decode_error",
      "input_bytes": "66fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF (long string marker) as sole byte in short string",
      "name": "short_string_ff_only",
      "type": "decode_error",
      "input_bytes": "66ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC between valid ASCII in short string",
      "name": "short_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "6861fc62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD between valid ASCII in short string",
      "name": "short_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "6861fd62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE between valid ASCII in short string",
      "name": "short_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "6861fe62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFF between valid ASCII in short string",
      "name": "short_string_ff_middle",
      "type": "decode_error",
      "input_bytes": "6861ff62",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes in one short string",
      "name": "short_string_all_structural_bytes",
      "type": "decode_error",
      "input_bytes": "69fcfdfeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC at start of multi-byte short string",
      "name": "short_string_fc_start",
      "type": "decode_error",
      "input_bytes": "68fc6162",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE at end of multi-byte short string",
      "name": "short_string_fe_end",
      "type": "decode_error",
      "input_bytes": "686162fe",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in long strings (invalid UTF-8) ===",
      "//note": "Long strings are FF-terminated. Bytes FC/FD/FE are valid data bytes within a long string (only FF terminates), but they are invalid UTF-8."
    },
    {
      "//": "0xFC as sole data byte in long string",
      "name": "long_string_fc_only",
      "type": "decode_error",
      "input_bytes": "fffcff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD as sole data byte in long string",
      "name": "long_string_fd_only",
      "type": "decode_error",
      "input_bytes": "fffdff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE as sole data byte in long string",
      "name": "long_string_fe_only",
      "type": "decode_error",
      "input_bytes": "fffeff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC between ASCII in long string",
      "name": "long_string_fc_middle",
      "type": "decode_error",
      "input_bytes": "ff61fc62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFD between ASCII in long string",
      "name": "long_string_fd_middle",
      "type": "decode_error",
      "input_bytes": "ff61fd62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE between ASCII in long string",
      "name": "long_string_fe_middle",
      "type": "decode_error",
      "input_bytes": "ff61fe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "All four structural bytes as long string data (only FC/FD/FE survive; FF terminates early)",
      "//note": "FF 61 FC FD FE 62 FF = long string 'a\\xFC\\xFD\\xFE b'",
      "name": "long_string_three_structural_bytes",
      "type": "decode_error",
      "input_bytes": "ff61fcfdfe62ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFC at start of long string data",
      "name": "long_string_fc_start",
      "type": "decode_error",
      "input_bytes": "fffc6162ff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "0xFE at end of long string data (just before FF terminator)",
      "name": "long_string_fe_before_terminator",
      "type": "decode_error",
      "input_bytes": "ff6162feff",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural bytes in strings inside containers ===",
      "//note": "These test that the decoder doesn't confuse data bytes with structural markers. FE inside a long string must NOT be treated as container end. FC/FD must NOT start nested containers."
    },
    {
      "//": "Array containing long string with 0xFE data byte — FE must not end the container",
      "//note": "FC FF FE FF FE = array( long_string('\\xFE') ) — structurally valid, but string is invalid UTF-8",
      "name": "array_long_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b3fffeffb5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing short string with 0xFE data byte",
      "//note": "FC D1 FE FE = array( short_string('\\xFE') )",
      "name": "array_short_string_with_fe_byte",
      "type": "decode_error",
      "input_bytes": "b366feb5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFC data byte — FC must not start a nested array",
      "//note": "FC FF FC FF FE = array( long_string('\\xFC') )",
      "name": "array_long_string_with_fc_byte",
      "type": "decode_error",
      "input_bytes": "b3fffcffb5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Array containing long string with 0xFD data byte — FD must not start a nested object",
      "//note": "FC FF FD FF FE = array( long_string('\\xFD') )",
      "name": "array_long_string_with_fd_byte",
      "type": "decode_error",
      "input_bytes": "b3fffdffb5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFC (short string)",
      "//note": "FD D1 FC 64 FE = object( key='\\xFC', value=0 )",
      "name": "object_key_short_string_with_fc",
      "type": "decode_error",
      "input_bytes": "b466fc00b5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object key containing 0xFE (long string)",
      "//note": "FD FF FE FF 64 FE = object( key='\\xFE', value=0 )",
      "name": "object_key_long_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b4fffeff00b5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Object value containing 0xFD (long string)",
      "//note": "FD D1 61 FF FD FF FE = object( key='a', value='\\xFD' )",
      "name": "object_value_long_string_with_fd",
      "type": "decode_error",
      "input_bytes": "b46661fffdfffffeb5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "Nested: array in object value, inner string has FE",
      "//note": "FD D1 61 FC D1 FE FE FE = object( key='a', value=array( short_string('\\xFE') ) )",
      "name": "nested_object_array_string_with_fe",
      "type": "decode_error",
      "input_bytes": "b46661b366feb5b5",
      "expected_error": "invalid_utf8"
    },
    {
      "//": "=== Structural confusion: premature FF termination ===",
      "//note": "When a long string's data is truncated (no FF terminator found), the decoder must report truncation, not silently misparse."
    },
    {
      "//": "Long string data contains only FE, no FF terminator — FE is data, not terminator",
      "//note": "FF 61 62 FE (no terminating FF) → truncated",
      "name": "long_string_unterminated_with_fe",
      "type": "decode_error",
      "input_bytes": "ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FE but no FF — must not end string or container",
      "//note": "FC FF 61 62 FE (no FF) → truncated",
      "name": "long_string_in_array_unterminated_fe",
      "type": "decode_error",
      "input_bytes": "b3ff6162fe",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FC but no FF — FC is data, not array start",
      "name": "long_string_in_array_unterminated_fc",
      "type": "decode_error",
      "input_bytes": "b3ff6162fc",
      "expected_error": "truncated"
    },
    {
      "//": "Long string in array, data contains FD but no FF — FD is data, not object start",
      "name": "long_string_in_array_unterminated_fd",
      "type": "decode_error",
      "input_bytes": "b3ff6162fd",
      "expected_error": "truncated"
    },
    {
      "//": "=== Valid structural parsing near string boundaries ===",
      "//note": "These are NOT error tests. They verify correct parsing when structural bytes (used properly) surround strings."
    },
    {
      "//": "Empty long string in array: FC FF FF FE",
      "name": "valid_empty_long_string_in_array",
      "type": "decode",
      "input_bytes": "b3ffffb5",
      "expected_value": [
        ""
      ]
    },
    {
      "//": "Two consecutive long strings in array: FC FF 61 FF FF 62 FF FE",
      "name": "valid_two_long_strings_in_array",
      "type": "decode",
      "input_bytes": "b3ff61ffff62ffb5",
      "expected_value": [
        "a",
        "b"
      ]
    },
    {
      "//": "Long string value in object: FD D1 61 FF 62 FF FE",
      "name": "valid_long_string_value_in_object",
      "type": "decode",
      "input_bytes": "b46661ff62ffb5",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Long string key and value in object: FD FF 61 FF FF 62 FF FE",
      "name": "valid_long_string_key_and_value",
      "type": "decode",
      "input_bytes": "b4ff61ffff62ffb5",
      "expected_value": {
        "a": "b"
      }
    },
    {
      "//": "Empty long string as object key: FD FF FF 64 FE",
      "name": "valid_empty_long_string_key",
      "type": "decode",
      "input_bytes": "b4ffff00b5",
      "expected_value": {
        "": 0
      }
    },
    {
      "//": "Array with mix of short and long strings: FC D1 61 FF 62 FF D1 63 FE",
      "name": "valid_mixed_short_long_strings",
      "type": "decode",
      "input_bytes": "b36661ff62ff6663b5",
      "expected_value": [
        "a",
        "b",
        "c"
      ]
    },
    {
      "//": "Nested arrays with long strings: FC FC FF 61 FF FE FC FF 62 FF FE FE",
      "name": "valid_nested_arrays_with_long_strings",
      "type": "decode",
      "input_bytes": "b3b3ff61ffb5b3ff62ffb5b5",
      "expected_value": [
        [
          "a"
        ],
        [
          "b"
        ]
      ]
    },
    {
      "//": "Deeply nested container with long string leaf: FC FC FC FF 78 FF FE FE FE",
      "name": "valid_deeply_nested_long_string",
      "type": "decode",
      "input_bytes": "b3b3b3ff78ffb5b5b5",
      "expected_value": [
        [
          [
            "x"
          ]
        ]
      ]
    },
    {
      "//": "Object containing array containing long string with FE-adjacent bytes (0xFB is valid)",
      "//note": "0xFB is not a structural byte — it's a reserved type code but valid as string data if valid UTF-8. However 0xFB is also not valid UTF-8, so we use 0x7B ('{') which is the last valid ASCII byte",
      "name": "valid_string_with_high_ascii_in_nested",
      "type": "decode",
      "input_bytes": "b46661b3ff7b7dffb5b5",
      "expected_value": {
        "a": [
          "{}"
        ]
      }
    }
  ]
}

{
  "type": "bonjson-test",
  "version": "1.0.0",
  "//": "Float encoding tests covering float16, float32, and float64",
  "tests": [
    {
      "//": "Float16 (bfloat16) uses type code 0x6a - 1.125 can be exactly represented",
      "name": "float16_1_125",
      "type": "encode",
      "input": 1.125,
      "expected_bytes": "6a903f"
    },
    {
      "//": "Float32 uses type code 0x6b",
      "name": "float32_39_875",
      "type": "encode",
      "input": 39.875,
      "expected_bytes": "6b00801f42"
    },
    {
      "//": "Float64 uses type code 0x6c - 1.234 requires full precision",
      "name": "float64_1_234",
      "type": "encode",
      "input": 1.234,
      "expected_bytes": "6c5839b4c876bef33f"
    },
    {
      "//": "Negative float16: -1.25",
      "name": "float16_neg1_25",
      "type": "encode",
      "input": -1.25,
      "expected_bytes": "6aa0bf"
    },
    {
      "//": "Small float that fits in float64: -5.923441e-50",
      "name": "float64_small",
      "type": "encode",
      "input": -5.923441e-50,
      "expected_bytes": "6c353cce818729b6b5"
    },
    {
      "//": "Decode tests - float32 encoding of 1.125 decodes correctly",
      "name": "decode_float32_1_125",
      "type": "decode",
      "input_bytes": "6b0000903f",
      "expected_value": 1.125
    },
    {
      "//": "Decode float64 encoding of 1.125",
      "name": "decode_float64_1_125",
      "type": "decode",
      "input_bytes": "6c000000000000f23f",
      "expected_value": 1.125
    },
    {
      "//": "Decode float64 pi using hex float for precise representation",
      "name": "decode_float64_pi_hex",
      "type": "decode",
      "input_bytes": "6c 182d4454fb210940",
      "expected_value": {"$number": "0x1.921fb54442d18p+1"}
    },
    {
      "//": "Decode float64 e using hex float for precise representation",
      "name": "decode_float64_e_hex",
      "type": "decode",
      "input_bytes": "6c 6957148b0abf0540",
      "expected_value": {"$number": "0x1.5bf0a8b145769p+1"}
    },
    {
      "//": "Round-trip tests for floats",
      "name": "roundtrip_float_1_125",
      "type": "roundtrip",
      "input": 1.125
    },
    {
      "name": "roundtrip_float_neg1_25",
      "type": "roundtrip",
      "input": -1.25
    },
    {
      "name": "roundtrip_float_pi",
      "type": "roundtrip",
      "input": 3.141592653589793
    },
    {
      "name": "roundtrip_float_e",
      "type": "roundtrip",
      "input": 2.718281828459045
    },
    {
      "name": "roundtrip_float_large",
      "type": "roundtrip",
      "input": 1.7976931348623157e308
    },
    {
      "name": "roundtrip_float_small_positive",
      "type": "roundtrip",
      "input": 2.2250738585072014e-308
    },
    {
      "name": "roundtrip_float_zero",
      "type": "roundtrip",
      "input": 0.0
    },
    {
      "//": "Integer values encoded as float should work",
      "name": "roundtrip_float_integer_value",
      "type": "roundtrip",
      "input": 42.0
    },
    {
      "//": "=== Negative zero tests ===",
      "name": "decode_float16_negative_zero",
      "type": "decode",
      "input_bytes": "6a0080",
      "expected_value": {"$number": "-0.0"}
    },
    {
      "name": "decode_float32_negative_zero",
      "type": "decode",
      "input_bytes": "6b00000080",
      "expected_value": {"$number": "-0.0"}
    },
    {
      "name": "decode_float64_negative_zero",
      "type": "decode",
      "input_bytes": "6c0000000000000080",
      "expected_value": {"$number": "-0.0"}
    },
    {
      "//": "=== Float precision boundary tests ===",
      "//note": "Values that overflow bfloat16 precision but fit float32",
      "name": "roundtrip_float_bfloat16_boundary",
      "type": "roundtrip",
      "input": 1.0078125
    },
    {
      "//": "Value with more precision than bfloat16 can represent",
      "name": "roundtrip_float_needs_float32",
      "type": "roundtrip",
      "input": 1.00390625
    },
    {
      "//": "Value that requires float64 precision",
      "name": "roundtrip_float_needs_float64",
      "type": "roundtrip",
      "input": 1.0000001192092896
    },
    {
      "//": "=== Subnormal float tests ===",
      "name": "roundtrip_float64_subnormal",
      "type": "roundtrip",
      "input": {"$number": "5e-324"}
    },
    {
      "//": "Smallest positive normal float64",
      "name": "roundtrip_float64_min_normal",
      "type": "roundtrip",
      "input": {"$number": "2.2250738585072014e-308"}
    },
    {
      "//": "=== Float special encoding tests ===",
      "//note": "Verify decoder accepts float values encoded in larger formats",
      "name": "decode_1_125_as_float64",
      "type": "decode",
      "input_bytes": "6c000000000000f23f",
      "expected_value": 1.125
    },
    {
      "name": "decode_1_25_as_float32",
      "type": "decode",
      "input_bytes": "6b0000a03f",
      "expected_value": 1.25
    },
    {
      "//": "Large magnitude that fits in float64",
      "name": "roundtrip_float_large_magnitude",
      "type": "roundtrip",
      "input": {"$number": "1e300"}
    },
    {
      "//": "Small magnitude that fits in float64",
      "name": "roundtrip_float_small_magnitude",
      "type": "roundtrip",
      "input": {"$number": "1e-300"}
    },
    {
      "//": "=== Negative zero roundtrip and encode tests ===",
      "name": "roundtrip_float_negative_zero",
      "type": "roundtrip",
      "input": {"$number": "-0.0"}
    },
    {
      "//": "Negative zero should encode to a float type (not integer 0)",
      "name": "encode_float_negative_zero",
      "type": "encode",
      "input": {"$number": "-0.0"},
      "expected_bytes": "6a0080"
    },
    {
      "//": "=== Additional precision boundary tests ===",
      "//note": "Values that test the boundary between float sizes",
      "name": "roundtrip_float_bfloat16_exact",
      "type": "roundtrip",
      "input": 1.5
    },
    {
      "//": "Value requiring float32 precision",
      "name": "roundtrip_float32_precision",
      "type": "roundtrip",
      "input": 1.00001
    },
    {
      "//": "Value requiring full float64 precision",
      "name": "roundtrip_float64_precision",
      "type": "roundtrip",
      "input": 1.0000000000000002
    },
    {
      "//": "=== Float boundary values ===",
      "name": "roundtrip_float64_max",
      "type": "roundtrip",
      "input": {"$number": "1.7976931348623157e+308"}
    },
    {
      "//": "Negative max float64",
      "name": "roundtrip_float64_neg_max",
      "type": "roundtrip",
      "input": {"$number": "-1.7976931348623157e+308"}
    },
    {
      "//": "Smallest positive normalized float64",
      "name": "roundtrip_float64_min_positive_normal",
      "type": "roundtrip",
      "input": {"$number": "2.2250738585072014e-308"}
    },
    {
      "//": "=== Float values that could be integers ===",
      "//note": "These whole numbers should still roundtrip correctly",
      "name": "roundtrip_float_whole_number_large",
      "type": "roundtrip",
      "input": 1000000.0
    },
    {
      "//": "Negative whole number as float",
      "name": "roundtrip_float_whole_number_negative",
      "type": "roundtrip",
      "input": -42.0
    },
    {
      "//": "=== Subnormal (denormalized) float tests ===",
      "//note": "Subnormals have exponent bits all zero but non-zero mantissa"
    },
    {
      "//": "Smallest positive subnormal float64 (2^-1074)",
      "name": "decode_float64_min_subnormal",
      "type": "decode",
      "//note2": "Bits: 0x0000000000000001 (little-endian: 01 00 00 00 00 00 00 00)",
      "input_bytes": "6c0100000000000000",
      "expected_value": {"$number": "5e-324"}
    },
    {
      "//": "Largest subnormal float64 (just below smallest normal)",
      "name": "decode_float64_max_subnormal",
      "type": "decode",
      "//note2": "Bits: 0x000fffffffffffff (little-endian: ff ff ff ff ff ff 0f 00)",
      "input_bytes": "6cffffffffffff0f00",
      "expected_value": {"$number": "2.225073858507201e-308"}
    },
    {
      "//": "Negative smallest subnormal",
      "name": "decode_float64_neg_min_subnormal",
      "type": "decode",
      "//note2": "Bits: 0x8000000000000001 (little-endian: 01 00 00 00 00 00 00 80)",
      "input_bytes": "6c0100000000000080",
      "expected_value": {"$number": "-5e-324"}
    },
    {
      "//": "Subnormal round-trip: smallest positive",
      "name": "roundtrip_float64_min_subnormal",
      "type": "roundtrip",
      "input": {"$number": "5e-324"}
    },
    {
      "//": "Subnormal round-trip: value in subnormal range",
      "name": "roundtrip_float64_subnormal_mid",
      "type": "roundtrip",
      "input": {"$number": "1e-310"}
    },
    {
      "//": "=== Float32 subnormals ===",
      "//note": "Float32 subnormals are smaller than float64 can represent as subnormal"
    },
    {
      "//": "Smallest positive subnormal float32 (2^-149)",
      "name": "decode_float32_min_subnormal",
      "type": "decode",
      "//note2": "Bits: 0x00000001 (little-endian: 01 00 00 00)",
      "input_bytes": "6b01000000",
      "expected_value": {"$number": "0x1p-149"}
    },
    {
      "//": "Largest subnormal float32",
      "name": "decode_float32_max_subnormal",
      "type": "decode",
      "//note2": "Bits: 0x007fffff (little-endian: ff ff 7f 00)",
      "input_bytes": "6bffff7f00",
      "expected_value": {"$number": "0x1.fffffcp-127"}
    }
  ]
}
